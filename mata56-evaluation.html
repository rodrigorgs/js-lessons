<!DOCTYPE html>
<html>
<title>js-lessons</title>
<meta charset="utf-8">
<!-- Theses are just icons config - created with realfavicongenerator.net -->
<link rel="apple-touch-icon" sizes="57x57" href="assets/images/icons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="assets/images/icons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="assets/images/icons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="assets/images/icons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="assets/images/icons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="assets/images/icons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="assets/images/icons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="assets/images/icons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="assets/images/icons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="assets/images/icons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="assets/images/icons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="assets/images/icons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="assets/images/icons/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="assets/images/icons/manifest.json">
<link rel="mask-icon" href="assets/images/icons/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="assets/images/icons/favicon.ico">
<meta name="msapplication-TileColor" content="#ffc40d">
<meta name="msapplication-TileImage" content="assets/images/icons/mstile-144x144.png">
<meta name="msapplication-config" content="assets/images/icons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<!-- These are just code mirror templates for editor -->
<link rel="stylesheet" href="assets/codemirror/theme/3024-day.css">
<link rel="stylesheet" href="assets/codemirror/theme/3024-night.css">
<link rel="stylesheet" href="assets/codemirror/theme/abcdef.css">
<link rel="stylesheet" href="assets/codemirror/theme/ambiance.css">
<link rel="stylesheet" href="assets/codemirror/theme/base16-dark.css">
<link rel="stylesheet" href="assets/codemirror/theme/bespin.css">
<link rel="stylesheet" href="assets/codemirror/theme/base16-light.css">
<link rel="stylesheet" href="assets/codemirror/theme/blackboard.css">
<link rel="stylesheet" href="assets/codemirror/theme/cobalt.css">
<link rel="stylesheet" href="assets/codemirror/theme/colorforth.css">
<link rel="stylesheet" href="assets/codemirror/theme/dracula.css">
<link rel="stylesheet" href="assets/codemirror/theme/eclipse.css">
<link rel="stylesheet" href="assets/codemirror/theme/elegant.css">
<link rel="stylesheet" href="assets/codemirror/theme/erlang-dark.css">
<link rel="stylesheet" href="assets/codemirror/theme/hopscotch.css">
<link rel="stylesheet" href="assets/codemirror/theme/icecoder.css">
<link rel="stylesheet" href="assets/codemirror/theme/isotope.css">
<link rel="stylesheet" href="assets/codemirror/theme/lesser-dark.css">
<link rel="stylesheet" href="assets/codemirror/theme/liquibyte.css">
<link rel="stylesheet" href="assets/codemirror/theme/material.css">
<link rel="stylesheet" href="assets/codemirror/theme/mbo.css">
<link rel="stylesheet" href="assets/codemirror/theme/mdn-like.css">
<link rel="stylesheet" href="assets/codemirror/theme/midnight.css">
<link rel="stylesheet" href="assets/codemirror/theme/monokai.css">
<link rel="stylesheet" href="assets/codemirror/theme/neat.css">
<link rel="stylesheet" href="assets/codemirror/theme/neo.css">
<link rel="stylesheet" href="assets/codemirror/theme/night.css">
<link rel="stylesheet" href="assets/codemirror/theme/paraiso-dark.css">
<link rel="stylesheet" href="assets/codemirror/theme/paraiso-light.css">
<link rel="stylesheet" href="assets/codemirror/theme/pastel-on-dark.css">
<link rel="stylesheet" href="assets/codemirror/theme/railscasts.css">
<link rel="stylesheet" href="assets/codemirror/theme/rubyblue.css">
<link rel="stylesheet" href="assets/codemirror/theme/seti.css">
<link rel="stylesheet" href="assets/codemirror/theme/solarized.css">
<link rel="stylesheet" href="assets/codemirror/theme/the-matrix.css">
<link rel="stylesheet" href="assets/codemirror/theme/tomorrow-night-bright.css">
<link rel="stylesheet" href="assets/codemirror/theme/tomorrow-night-eighties.css">
<link rel="stylesheet" href="assets/codemirror/theme/ttcn.css">
<link rel="stylesheet" href="assets/codemirror/theme/twilight.css">
<link rel="stylesheet" href="assets/codemirror/theme/vibrant-ink.css">
<link rel="stylesheet" href="assets/codemirror/theme/xq-dark.css">
<link rel="stylesheet" href="assets/codemirror/theme/xq-light.css">
<link rel="stylesheet" href="assets/codemirror/theme/yeti.css">
<link rel="stylesheet" href="assets/codemirror/theme/zenburn.css">
<!-- You can remove or leave at is -->
<!-- Stylesheets system - please don't remove :) -->
<link rel="stylesheet" href="assets/main.css">
<link rel="stylesheet" href="assets/codemirror/codemirror.css">
<link rel="stylesheet" href="assets/codemirror/addons/show-hint.css">
<link rel="stylesheet" href="assets/codemirror/addons/lint.css">
<link rel="stylesheet" href="assets/codemirror/addons/fullscreen.css">
<!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/ramda/0.19.1/ramda.min.js"></script> -->
<script type="text/javascript">
	// Adds the implementation for Array.prototype.concatAll()
	function defineConcatAll() {
		Array.prototype.concatAll = function () {
			var results = [];

			this.forEach(function(subArray) {
				results.push.apply(results, subArray);
			});

			return results;
		};
	}

	/**
	 * Add the implementation for Array.prototype.concatMap()
	 */
	function defineConcatMap() {
		Array.prototype.concatMap = function(fnc) {
			return this.
				map(function (e) {
					return fnc(e);
				}).
				// apply the concatAll function to flatten the two-dimensional array
				concatAll();
		};
	}

	/**
	 * This function will be executed at the begining of each verifier function
	 */
	function preVerifierHook() {
		// Add helpers to prevent 'undefined is not a function' like errors
		defineConcatAll();
		defineConcatMap();
	}

	function showLessonErrorMessage(exp, got, note, div){
		var preTag;
		var expected = JSON.stringify(JSON.parse(exp), undefined, 4);

		div.innerHTML = "<h4>Expected:</h4>";
		preTag = document.createElement("pre");
		preTag.innerHTML += expected;
		div.appendChild(preTag);
		div.innerHTML += "<h4>Got:</h4>";
		preTag = document.createElement("pre");
		preTag.innerHTML += got;
		div.appendChild(preTag);
		
		div.innerHTML += (note !== "") ? ("<h4>Note</h4><p style=\"margin-left: 25px;\">" + note + "</p>") : ""; 
		div.className = "info";
	}
</script>

<script type="text/javascript">
function simplesEval(str, info) {
	var cmd = "(function(){" + str + "})();";
	eval(cmd);
	return "Success!";
}
</script>

<xmp theme="united" style="display:none;">
<div id="loader-wrapper">
	<div id="loader"></div>
	<div class="loader-section section-left"></div>
	<div class="loader-section section-right"></div>
</div>



# Programação funcional

## Estratégias de avaliação

Uma estratégia de avaliação determina quando uma expressão passada como argumento para uma função é avaliada.

Existem duas categorias principais de estratégias:

- Avaliação estrita (ou ansiosa, *eager*): os argumentos são avaliados completamente antes da aplicação da função
- Avaliação não-estrita (ou preguiçosa, *lazy*)

Considere o exemplo a seguir. Antes de executá-lo, tente adivinhar o que será escrito no console, na ordem correta.

<div class="lesson">
<textarea class="code">
function cumprimenta(nome, pontuacao) {
	console.log("pre-cumprimenta");
	console.log("Alo, " + nome + pontuacao);
	console.log("pos-cumprimenta");
}
function pontoFinal(entusiasmado) {
	console.log("pre-pontoFinal");
	return entusiasmado ? "!" : ".";
}
function diminutivo(nome) {
	console.log("pre-diminutivo");
	return nome + "zinho";
}

// chama função cumprimenta
console.log("pre-chamada");
cumprimenta(diminutivo("Fulano"), pontoFinal(true));
console.log("pos-chamada");
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

Acertou? Chegou perto? Para entender o que aconteceu, temos que falar de **estratégias de avaliação**.


## Conceitos

- Parâmetro formal: variável que aparece na definição de uma função
- Parâmetro real (ou argumento): variável ou valor passado em uma chamada para uma função

```javascript
function soma(a, b) { // a e b são parâmetros formais
	return a + b;
}
var x = 1, y = 2;
var z = soma(2*x, y); // 2*x e y são argumentos
                      // (parâmetros reais)
```

## Avaliação estrita

**Passagem por valor**: o valor da expressão é avaliado antes da chamada da função; a função recebe uma cópia do valor.

**Passagem por referência**: a função recebe uma referência para a variável; a função pode modificar a variável e atribuir um novo valor a ela. Nesse caso o argumento não pode ser qualquer expressão; deve ser uma variável. Exemplo: função `swap` em Pascal:

```pascal
procedure swap(var x, y: integer);
var
   temp: integer;

begin
   temp := x;
   x:= y;
   y := temp;
end;
```

Não é possível escrever uma função similar em Javascript em usar artifícios, pois Javascript não dá suporte a passagem de parâmetros por referência.

**Passagem por compartilhamento** (às vezes chamado de passagem por referência): como na passagem por referência, a função consegue modificar o objeto passado, mas não consegue atribuir a variável a outro valor. Exemplo:

<div class="lesson">
<textarea class="code">
function insere(vetor, elemento) {
	vetor.push(elemento);
}
var x = [1, 2, 3];
insere(x, 4);
alert(x);
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

Podemos usar a passagem por compartilhamento para emular passagem por referência e escrever uma função `swap` em Javascript:

<div class="lesson">
<textarea class="code">
function swap(obj) {
	var temp = obj.a;
	obj.a = obj.b;
	obj.b = temp;
}
var a = 1, b = 2;
var obj = {"a": a, "b": b};
swap(obj);
a = obj.a;
b = obj.b;
alert([a, b]);
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

**Passagem por cópia e restauração (copy-restore)**. Como passagem por compartilhamento, útil no contexto de chamadas remotas (o chamador e a função estão em processos diferentes). O valor é copiado para a função, e ao final o novo valor é copiado de volta para o chamador.

## Avaliação não-estrita

**Chamada por nome**. Nesta avaliação, os argumentos não são avaliados de maneira completa, tais argumentos são substituídos diretamente dentro do corpo da função. Se um parêmetro não é usado na avaliação da função, este nunca será avaliado, e se o parâmetro é usado varias vezes, este é reavaliado a cada vez.

**Chamada por necessidade**. Chamada por necessidade é uma versão da chamada por nome, se o argumento da função é avaliado, seu valor é gravado para uso posterior.

**Chamada por expansão de macro**. Ver `#define` em C.

## Lazy evaluation em Javascript

Embora Javascript não permita diretamente a passagem de parâmetros por necessidade, podemos escrever programas que usam essa estratégia.

Considere o seguinte exemplo, que tenta emular o operador ternário `condicao ? valorVerdadeiro : valorFalso`:

<div class="lesson">
<textarea class="code">
function ternario(condicao, valorTrue, valorFalse) {
	console.log("chamou ternario");
	if (condicao) {
		return valorTrue;
	} else {
		return valorFalse;
	}
}
function soma(a, b) {
	console.log("chamou soma(" + a + "," + b + ")");
	return a + b;
}
var curso = "Computacao";
var valorInscricao = ternario(curso === "Computacao", soma(20, 10), soma(40, 20));
console.log(valorInscricao);
// É equivalente ao de baixo?
// var valorInscricao = curso === "Computacao" ? soma(20, 10) : soma(40, 20));
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

Você deve ter percebido que é impossível emular perfeitamente o operador ternário, pois os argumentos são avaliados de forma estrita. O único jeito é reescrever `ternario` para receber funções, e não valores.

<div class="lesson">
<textarea class="code">
function ternario(condicao, funcaoTrue, funcaoFalse) {
	console.log("chamou ternario");
	if (condicao) {
		return funcaoTrue();
	} else {
		return funcaoFalse();
	}
}
function soma(a, b) {
	console.log("chamou soma(" + a + "," + b + ")");
	return a + b;
}
var curso = "Computacao";
var valorInscricao = ternario(curso === "Computacao", () => soma(20, 10), () => soma(40, 20));
console.log(valorInscricao);
// É equivalente ao de baixo?
// var valorInscricao = curso === "Computacao" ? soma(20, 10) : soma(40, 20));
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

<!--
### Exemplo: logging

<div class="lesson">
<textarea class="code">
function log(nivel, mensagem) {
	if (nivel >= nivelAtual) {
		console.log(mensagem);
	}
}
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div> -->

### Memoização

Consideremos outro exemplo:

<div class="lesson">
<textarea class="code">
function repete(string, nvezes) {
	var i;
	for (i = 0; i < nvezes; i++) {
		console.log(string);
	}
}
function concatena(str1, str2) {
	console.log("concatena");
	return str1 + ", " + str2;
}
var tranquilo = "tá tranquilo";
var favoravel = "tá favorável";
repete(concatena(tranquilo, favoravel), 4);
console.log("======");
repete(concatena(tranquilo, favoravel), 0);
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

Na primeira chamada a `repete`, a expressão `concatena(tranquilo, favoravel)` é avaliada apenas uma vez, e seu valor é passado ao parâmetro `string`. Na segunda chamada, a expressão é avaliada, mas seu valor nunca chega a ser usado (por ele é não é impresso nenhuma vez). Isso representa um desperdício de processamento! Para resolver isso, vamos usar uma estratégia de avaliação preguiçosa:

<div class="lesson">
<textarea class="code">
function repete(lazyString, nvezes) {
	var i;
	for (i = 0; i < nvezes; i++) {
		console.log(lazyString());
	}
}
function concatena(str1, str2) {
	console.log("concatena");
	return str1 + ", " + str2;
}
var tranquilo = "tá tranquilo";
var favoravel = "tá favorável";
repete(() => concatena(tranquilo, favoravel), 4);
console.log("======");
repete(() => concatena(tranquilo, favoravel), 0);
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

Pronto! Agora, no segundo caso (`nvezes` igual a `0`), a função `concatena` não é chamada, porque não é necessário! Em compensação, a função é chamada 4 vezes no primeiro `repete`, o que também é um desperdício, já que o resultado é sempre o mesmo. Essa é a desvantagem da passagem de parâmetros **por nome**. Vamos transformar em passagem **por necessidade**; para isso, é preciso guardar o valor na primeira chamada.

<div class="lesson">
<textarea class="code">
function repete(lazyString, nvezes) {
	var i, memo;
	for (i = 0; i < nvezes; i++) {
		if (memo === undefined) {
			memo = lazyString();
		}
		console.log(memo);
	}
}
function concatena(str1, str2) {
	console.log("concatena");
	return str1 + ", " + str2;
}
var tranquilo = "tá tranquilo";
var favoravel = "tá favorável";
repete(() => concatena(tranquilo, favoravel), 4);
console.log("======");
repete(() => concatena(tranquilo, favoravel), 0);
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

Essa técnica de guardar o retorno de uma função para consultar em chamadas subsequentes à função é chamada **memoização**.

Exercício: implementar `chamadaMemoizada(f)`.

Aplicação prática: logging.

```javascript
nivelAtual = 3;
function log(nivel, mensagem) {
	if (nivel >= nivelAtual) {
		console.log(mensagem);
	}
}

if (nivelAtual >= 3) { // otimização para evitar computar a mensagem se não for ser exibida
	log(3, "Usuário clicou em " + convertePosicao(mouse.x) + ", " + convertePosicao(mouse.y));
}
```

## Listas preguiçosas com iterators

Um objeto é um iterador quando ele sabe como acessar itens de uma coleção um de cada vez, enquanto mantém o registro da posição atual dentro da sequência.

Em Javascript, um iterador é um objeto que fornece um método `next()` que retorna o próximo item na sequência. Esse método retorna um objeto com duas propriedades: `done` (indica se a sequência terminou) e `value` (representa o item atual da sequência).

<div class="lesson">
<textarea class="code">
function criaIterador(array) {
	var indice = 0;

	return {
		next: function() {
			if (indice < array.length) {
				return {value: array[indice++], done: false};
			} else {
				return {value: undefined, done: true};
			}
		}
	};
}
var iter = criaIterador(['a', 'b', 'c']);
var elem = iter.next();
while (!elem.done) {
	console.log("elem: " + elem.value);
	elem = iter.next();
}
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

Vejamos outro exemplo, desta vez com um iterador infinito:

<div class="lesson">
<textarea class="code">
function criaIteradorFib() {
	var a = 1, b = 1;

	obj = {
		next: function() {
			var prox = a + b;
			a = b;
			b = prox;
			return {value: prox, done: false};
		}
	};

	return obj;
}
var iter = criaIteradorFib();
var elem = iter.next();
while (!elem.done && elem.value < 100) {
	console.log(elem.value);
	elem = iter.next();
}
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

O conceito de gerador ou **função geradora** (generator function) permite escrever esse código de forma muito mais intuitiva. Para definir um gerador, use `function*`. Para chamar um gerador, você pode usar o mesmo esquema de `next()`, `done` e `value` ou pode usar `for (x of gerador())`:

<div class="lesson">
<textarea class="code">
function* geraFib() {
	var a = 1, b = 1, prox;

	while (true) {
		prox = a + b;
		a = b;
		b = prox;
		yield prox;
	}
}
for (x of geraFib()) {
	if (x >= 100) break;
	console.log(x);
}
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>

Podemos criar uma função genérica que executa uma função para os primeiros `n` valores de um generator:

<div class="lesson">
<textarea class="code">
function* geraFib() {
    var a = 1, b = 1, prox;

    while (true) {
        prox = a + b;
        a = b;
        b = prox;
        yield prox;
    }
}

function take(gen, n, fn) {
    var i = 0, x;
    for (x of gen()) {
        if (i >= n) break;
        fn(x);
        i++;
    }
}

take(geraFib, 5, x => console.log(x));
</textarea>
<div class="output"></div>
<div class="output"></div>
<pre class="verifier">function(str, info) { return simplesEval(str, info); }</pre>
<button class="go">Rodar</button>
</div>





<div id="START-EXERCISE"></div>
<div id="END-EXERCISE"></div>

</xmp>

<!-- Nice librarie for functional programming -->
<script type="text/javascript" src="assets/underscore/underscore-min.js"></script>

<!-- Since strapdown is stupid and can change the value of textarea, we need to make a backup of all code -->
<script type="text/javascript">
	replaceAll = function(search, replacement, object) {
	    return object.replace(new RegExp(search, 'g'), replacement);
	};
</script>

<!-- Libraries for interface -->
<script src="assets/strapdown/v/0.2/strapdown.js"></script>
<script src="assets/codemirror/codemirror.js"></script>
<!-- Some code mirrors addons -->
<script src="assets/codemirror/javascript.js"></script>
<script src="assets/codemirror/addons/matchbrackets.js"></script>
<script src="assets/codemirror/addons/autorefresh.js"></script>
<script src="assets/codemirror/addons/javascript-hint.js"></script>
<script src="assets/codemirror/addons/jshint.js"></script>
<script src="assets/codemirror/addons/javascript-lint.js"></script>
<script src="assets/codemirror/addons/lint.js"></script>
<script src="assets/codemirror/addons/show-hint.js"></script>
<script src="assets/codemirror/addons/fullscreen.js"></script>
<script src="assets/codemirror/addons/active-line.js"></script>

<!-- APP LIBRARIES --> 
<script src="assets/app/wordlist.js"></script>
<!-- <script src="assets/app/utils.js"></script> -->
<!-- <script src="assets/app/main.js"></script> -->

<script type="text/javascript">
	// Hide the remain exercises without remove markdown support
	// Remember to use functional paradigm :p
	(function (){
		var x = document.getElementById("START-EXERCISE");
		while(x.nextElementSibling.id != "END-EXERCISE"){
			x.style.display = "none";
			x = x.nextElementSibling;
		}

		// Since text area only have javascript code, is not necessary left "<a href="">"
		// , or "<em>" 
		x = document.getElementsByClassName("code");
		_.each(x, el => {
			el.value = el.value.replace(/(<a\ href=").*(">)/g, 		"");
			el.value = el.value.replace(new RegExp("</a>", 'g'), 	"");
			el.value = el.value.replace(new RegExp("<em>", 'g'), 	"*");
			el.value = el.value.replace(new RegExp("</em>", 'g'), 	"*");
		});
	})();

	/*(function (){
		var x = document.getElementsByClassName("go");
		
		// Just unhide to confirm this possibility
		_.each(x, function(el) {
			el.onclick = (ev) =>  {

				p = ev.target.parentElement.nextElementSibling;
				while(!p.id.startsWith("lessonB")){
					p = p.nextElementSibling;
				}

				p = p.nextElementSibling;
				while(!p.id.startsWith("lessonE")){
					p.style.display = "";
					p = p.nextElementSibling;
				}

				p.previousElementSibling.scrollIntoView();
			}
		}); 
	})();*/
	
	var codeMirrorEditors = [];
	var lessons = document.getElementsByClassName("lesson");

	function scrollTo(element, to, duration) {
	    var difference 	= (to + 60) - element.scrollTop;
	    var perTickSize = (difference / duration).toFixed();
	    var perTickTime = (duration / difference).toFixed(2);
	    var pageHeight	= window.innerHeight;

	    console.log("St = " + perTickSize + " | Ts = " + perTickTime + " | S = " + difference + " | D = " + duration);

	    var scrollingId = setInterval( _ => {
	    	if((duration <= 0) || ((pageHeight + element.scrollTop) > element.offsetHeight)){
	    		clearInterval(scrollingId);
	    		return;
	    	}
	    	console.log(element.scrollTop);
	    	duration -= perTickTime;
	    	element.scrollTop = element.scrollTop + perTickSize;
	    }, perTickTime);		
	}

	_.each(lessons, function (el){
		var code = el.children[0];
		var output = el.children[1];
		var info = el.children[2]; 
		var verifierScript = el.children[3].textContent;
		var go = el.children[4];

		code.style.visibility = null;
		code.style.display = null;

		CodeMirror.defaults.lint = true;

		var codeMirror = CodeMirror.fromTextArea(code, {
			    lineNumbers: true,
			    mode: "javascript",
			    gutters: ["CodeMirror-lint-markers"],
			    lint: true,
				matchBrackets: true,
				autoRefresh: true,
				tabSize: 4,
				//styleActiveLine: true,
				indentWithTabs: false,
				hint: true,
				extraKeys: {
					"F4": function(cm) {
						cm.setOption("fullScreen", !cm.getOption("fullScreen"));
					},
					"Esc": function(cm) {
						if (cm.getOption("fullScreen")) cm.setOption("fullScreen", false);
					},
					"Ctrl-Space": "autocomplete"
				}
			});

		codeMirrorEditors.push(codeMirror);

		configureReadOnlyLines(codeMirror);

		go.onclick = (ev) =>  {
			// console.log("EVENT OK!");
			// console.log(ev);
			try{
				var verificador = eval("(" + verifierScript + ")");
				output.textContent = verificador(codeMirror.getValue(), info, el);
			} catch (ex) {
				alert(ex);
			}

			if((output.textContent !== "Success!") && (output.textContent !== "YUPPPEEEE!")){
				output.className = "error";
				output.textContent = "Error!";
				return;
			}

			output.className = "success";
			info.className = "output";

			// var p = ev.target.parentElement.nextElementSibling;
			// while(!p.id.startsWith("lessonB")){
			// 	p = p.nextElementSibling;
			// }

			// p = p.nextElementSibling;
			// while(!p.id.startsWith("lessonE")){
			// 	p.style.display = "";
			// 	p = p.nextElementSibling;
			// }		

			//scrollTo(document.body, output.offsetTop, 600);
		};
	});

	var input = document.getElementById("select");
	function selectTheme() {
		var theme = input.options[input.selectedIndex].textContent;
		_.each(codeMirrorEditors, el => {
			el.setOption("theme", theme)
		});
		location.hash = "#" + theme;
	}
	var choice = (location.hash && location.hash.slice(1)) ||
	             (document.location.search &&
	             decodeURIComponent(document.location.search.slice(1)));
	if (choice) {
		input.value = choice;
		_.each(codeMirrorEditors, el => {
			el.setOption("theme", choice)
		});
	}
	CodeMirror.on(window, "hashchange", function() {
		var theme = location.hash.slice(1);
		if (theme) {
			input.value = theme;
			selectTheme();
		}
	});

	// After all page got rendered remove loader
	document.body.classList.add("loaded");
	document.styleSheets[49].ownerNode.id = "pagetheme";

	/**
	 * This function assumes that lines containing three consecutive
	 * slahes (---) are markers to delimit read-only text.
	 * If a marker exists, then all lines not between consecutive markers
	 * become read-only.
	 * Example:
	 * <textarea>
	 *   This line is read-only
	 *   ---
	 *   This line is read-write
	 *   ---
	 *   This line is also read-only
	 * </textarea>
	 */
	function configureReadOnlyLines(codeMirrorEditor) {
		var i,
			doc = codeMirrorEditor.doc,
			lines = doc.children[0].lines.map(line => line.text);
			separatorIndices = _.range(lines.length).filter(idx => lines[idx].indexOf("---") != -1);

		if (separatorIndices.length > 0) {
			separatorIndices = [0].concat(separatorIndices, lines.length - 1);
			for (i = 0; i < separatorIndices.length - 1; i += 2) {
				doc.markText({line: separatorIndices[i], ch: 0},
					{line: separatorIndices[i + 1] + 1, ch: 0},
					{readOnly: true, css: "opacity: 0.6"});
			}
		}
	}

	// Allow change theme page
	function selectThemePage(element){
		var sheet = document.getElementById("pagetheme");
		refname = sheet.href;

		document.body.classList.remove("loaded");
		sheet.href = refname.replace(/\/themes\/.*/g, "/themes/" + element.value + ".min.css");
		setTimeout(_ => {document.body.classList.add("loaded")}, 350);
	}
</script>

</html>
<!-- TODO
	+ Remember to use jekyll, I think it's a good idea for clean the code
	+ USE http://myjson.com/api to store JSON with progress of each student
	+ USE https://ihatetomatoes.net/create-custom-preloading-screen/ while markdown is parsed and content are hidding
-->